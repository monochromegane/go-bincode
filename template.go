package bincode

type binCode struct {
	Package string
}

type templates []*template

func (ts templates) toString() string {
	var template string
	for _, t := range ts {
		template = template + t.text
	}
	return template
}

var codeTemplates = templates{
	packageTpl,
	importTpl,
	initTpl,
	binCoderTpl,
}

type template struct {
	name string
	text string
}

var packageTpl = &template{
	name: "package",
	text: `// Code generated by go-bincode.
// DO NOT EDIT!
package {{ .Package }}
`}

var importTpl = &template{
	name: "import",
	text: `
import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)
`}

var initTpl = &template{
	name: "init",
	text: `
func init() {
	var code string
	var list bool
	var restore bool

	f := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)

	f.StringVar(&code, "show-code", "", "show source code")
	f.BoolVar(&list, "list-code", false, "list source code")
	f.BoolVar(&restore, "restore-code", false, "restore source code")

	buf := &bytes.Buffer{}
	f.SetOutput(buf)

	err := f.Parse(os.Args[1:])
	if err != nil {
		// Continue if flag not found
		if strings.Contains(err.Error(), "flag provided but not defined:") {
			return
		}
		// Continue if flag is "h" or "help"
		if err == flag.ErrHelp {
			fmt.Fprintln(os.Stderr, buf.String())
			return
		}
		// Exit if flag has error
		fmt.Fprintln(os.Stderr, buf.String())
		os.Exit(2)
	}

	if list {
		newBinCoder().listCode()
		os.Exit(0)
	}

	if code != "" {
		err := newBinCoder().showCode(code)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		os.Exit(0)
	}

	if restore {
		newBinCoder().restoreCode()
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		os.Exit(0)
	}
}
`}

var binCoderTpl = &template{
	name: "binCoder",
	text: `
type binCoder struct {
	writer io.Writer
}

func newBinCoder() *binCoder {
	return &binCoder{writer: os.Stdout}
}

func (b binCoder) listCode() {
	for _, a := range AssetNames() {
		b.out(a)
	}
}

func (b binCoder) showCode(name string) error {
	asset, err := Asset(name)
	if err != nil {
		return err
	}
	b.out(string(asset))
	return nil
}

func (b binCoder) restoreCode() error {
	for _, name := range AssetNames() {
		// mkdir
		if err := os.MkdirAll(filepath.Dir(name), 0755); err != nil {
			return err
		}
		// write file
		asset, err := Asset(name)
		if err != nil {
			return err
		}
		err = ioutil.WriteFile(name, asset, 0644)
		if err != nil {
			return err
		}
	}
	return nil
}

func (b binCoder) out(s string) {
	fmt.Fprintln(b.writer, s)
}
`}
