package bincode

type binCode struct {
	Package string
}

type templates []*template

func (ts templates) toString() string {
	var template string
	for _, t := range ts {
		template = template + t.text
	}
	return template
}

var codeTemplates = templates{
	packageTpl,
	importTpl,
	initTpl,
	binCoderTpl,
}

type template struct {
	name string
	text string
}

var packageTpl = &template{
	name: "package",
	text: `// Code generated by go-bincode.
// DO NOT EDIT!
package {{ .Package }}
`}

var importTpl = &template{
	name: "import",
	text: `
import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"strings"
)
`}

var initTpl = &template{
	name: "init",
	text: `
func init() {
	var code string
	var list bool
	var restore bool

	f := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)

	f.StringVar(&code, "show-code", "", "show source code")
	f.BoolVar(&list, "list-code", false, "list source code")
	f.BoolVar(&restore, "restore-code", false, "restore source code")

	buf := &bytes.Buffer{}
	f.SetOutput(buf)

	err := f.Parse(os.Args[1:])
	if err != nil {
		// Continue if flag not found
		if strings.Contains(err.Error(), "flag provided but not defined:") {
			return
		}
		// Continue if flag is "h" or "help"
		if err == flag.ErrHelp {
			fmt.Fprintln(os.Stderr, buf.String())
			return
		}
		// Exit if flag has error
		fmt.Fprintln(os.Stderr, buf.String())
		os.Exit(2)
	}

	if list {
		binCoder{}.listCode()
		os.Exit(0)
	}

	if code != "" {
		err := binCoder{}.showCode(code)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		os.Exit(0)
	}
}
`}

var binCoderTpl = &template{
	name: "binCoder",
	text: `
type binCoder struct {}

func (b binCoder) listCode() {
	for _, a := range AssetNames() {
		fmt.Println(a)
	}
}

func (b binCoder) showCode(name string) error {
	asset, err := Asset(name)
	if err != nil {
		return err
	}
	fmt.Println(string(asset))
	return nil
}
`}
